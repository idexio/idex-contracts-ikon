/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export type DelegatedKeyAuthorizationStruct = {
  nonce: PromiseOrValue<BigNumberish>;
  delegatedPublicKey: PromiseOrValue<string>;
  signature: PromiseOrValue<BytesLike>;
};

export type DelegatedKeyAuthorizationStructOutput = [
  BigNumber,
  string,
  string
] & { nonce: BigNumber; delegatedPublicKey: string; signature: string };

export type OrderStruct = {
  signatureHashVersion: PromiseOrValue<BigNumberish>;
  nonce: PromiseOrValue<BigNumberish>;
  walletAddress: PromiseOrValue<string>;
  orderType: PromiseOrValue<BigNumberish>;
  side: PromiseOrValue<BigNumberish>;
  quantityInPips: PromiseOrValue<BigNumberish>;
  isQuantityInQuote: PromiseOrValue<boolean>;
  limitPriceInPips: PromiseOrValue<BigNumberish>;
  stopPriceInPips: PromiseOrValue<BigNumberish>;
  clientOrderId: PromiseOrValue<string>;
  timeInForce: PromiseOrValue<BigNumberish>;
  selfTradePrevention: PromiseOrValue<BigNumberish>;
  cancelAfter: PromiseOrValue<BigNumberish>;
  walletSignature: PromiseOrValue<BytesLike>;
  isSignedByDelegatedKey: PromiseOrValue<boolean>;
  delegatedKeyAuthorization: DelegatedKeyAuthorizationStruct;
};

export type OrderStructOutput = [
  number,
  BigNumber,
  string,
  number,
  number,
  BigNumber,
  boolean,
  BigNumber,
  BigNumber,
  string,
  number,
  number,
  BigNumber,
  string,
  boolean,
  DelegatedKeyAuthorizationStructOutput
] & {
  signatureHashVersion: number;
  nonce: BigNumber;
  walletAddress: string;
  orderType: number;
  side: number;
  quantityInPips: BigNumber;
  isQuantityInQuote: boolean;
  limitPriceInPips: BigNumber;
  stopPriceInPips: BigNumber;
  clientOrderId: string;
  timeInForce: number;
  selfTradePrevention: number;
  cancelAfter: BigNumber;
  walletSignature: string;
  isSignedByDelegatedKey: boolean;
  delegatedKeyAuthorization: DelegatedKeyAuthorizationStructOutput;
};

export type OrderBookTradeStruct = {
  baseAssetSymbol: PromiseOrValue<string>;
  quoteAssetSymbol: PromiseOrValue<string>;
  baseQuantityInPips: PromiseOrValue<BigNumberish>;
  quoteQuantityInPips: PromiseOrValue<BigNumberish>;
  makerFeeQuantityInPips: PromiseOrValue<BigNumberish>;
  takerFeeQuantityInPips: PromiseOrValue<BigNumberish>;
  priceInPips: PromiseOrValue<BigNumberish>;
  makerSide: PromiseOrValue<BigNumberish>;
};

export type OrderBookTradeStructOutput = [
  string,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  number
] & {
  baseAssetSymbol: string;
  quoteAssetSymbol: string;
  baseQuantityInPips: BigNumber;
  quoteQuantityInPips: BigNumber;
  makerFeeQuantityInPips: BigNumber;
  takerFeeQuantityInPips: BigNumber;
  priceInPips: BigNumber;
  makerSide: number;
};

export type OraclePriceStruct = {
  baseAssetSymbol: PromiseOrValue<string>;
  timestampInMs: PromiseOrValue<BigNumberish>;
  priceInAssetUnits: PromiseOrValue<BigNumberish>;
  signature: PromiseOrValue<BytesLike>;
};

export type OraclePriceStructOutput = [string, BigNumber, BigNumber, string] & {
  baseAssetSymbol: string;
  timestampInMs: BigNumber;
  priceInAssetUnits: BigNumber;
  signature: string;
};

export type BalanceStruct = {
  isMigrated: PromiseOrValue<boolean>;
  balanceInPips: PromiseOrValue<BigNumberish>;
  lastUpdateTimestampInMs: PromiseOrValue<BigNumberish>;
};

export type BalanceStructOutput = [boolean, BigNumber, BigNumber] & {
  isMigrated: boolean;
  balanceInPips: BigNumber;
  lastUpdateTimestampInMs: BigNumber;
};

export type WithdrawalStruct = {
  nonce: PromiseOrValue<BigNumberish>;
  walletAddress: PromiseOrValue<string>;
  grossQuantityInPips: PromiseOrValue<BigNumberish>;
  gasFeeInPips: PromiseOrValue<BigNumberish>;
  walletSignature: PromiseOrValue<BytesLike>;
};

export type WithdrawalStructOutput = [
  BigNumber,
  string,
  BigNumber,
  BigNumber,
  string
] & {
  nonce: BigNumber;
  walletAddress: string;
  grossQuantityInPips: BigNumber;
  gasFeeInPips: BigNumber;
  walletSignature: string;
};

export interface Exchange_v4Interface extends utils.Interface {
  functions: {
    "_depositIndex()": FunctionFragment;
    "_walletExits(address)": FunctionFragment;
    "addMarket(string,uint64,uint64,uint64,uint64,uint64,uint64)": FunctionFragment;
    "deposit(uint256)": FunctionFragment;
    "executeOrderBookTrade((uint8,uint128,address,uint8,uint8,uint64,bool,uint64,uint64,string,uint8,uint8,uint64,bytes,bool,(uint128,address,bytes)),(uint8,uint128,address,uint8,uint8,uint64,bool,uint64,uint64,string,uint8,uint8,uint64,bytes,bool,(uint128,address,bytes)),(string,string,uint64,uint64,int64,uint64,uint64,uint8),(string,uint64,uint256,bytes)[])": FunctionFragment;
    "invalidateOrderNonce(uint128)": FunctionFragment;
    "liquidate(address,int64[],(string,uint64,uint256,bytes)[])": FunctionFragment;
    "loadBalanceBySymbol(address,string)": FunctionFragment;
    "loadBalanceInPipsBySymbol(address,string)": FunctionFragment;
    "loadCustodian()": FunctionFragment;
    "loadFeeWallet()": FunctionFragment;
    "loadOutstandingWalletFunding(address)": FunctionFragment;
    "loadPartiallyFilledOrderQuantityInPips(bytes32)": FunctionFragment;
    "loadTotalAccountValue(address,(string,uint64,uint256,bytes)[])": FunctionFragment;
    "loadTotalInitialMarginRequirement(address,(string,uint64,uint256,bytes)[])": FunctionFragment;
    "loadTotalMaintenanceMarginRequirement(address,(string,uint64,uint256,bytes)[])": FunctionFragment;
    "publishFundingMutipliers((string,uint64,uint256,bytes)[],int64[])": FunctionFragment;
    "removeAdmin()": FunctionFragment;
    "removeDispatcher()": FunctionFragment;
    "setAdmin(address)": FunctionFragment;
    "setChainPropagationPeriod(uint256)": FunctionFragment;
    "setCustodian(address)": FunctionFragment;
    "setDelegateKeyExpirationPeriod(uint64)": FunctionFragment;
    "setDepositIndex()": FunctionFragment;
    "setDispatcher(address)": FunctionFragment;
    "setFeeWallet(address)": FunctionFragment;
    "updateWalletFunding(address)": FunctionFragment;
    "withdraw((uint128,address,uint64,uint64,bytes),(string,uint64,uint256,bytes)[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "_depositIndex"
      | "_walletExits"
      | "addMarket"
      | "deposit"
      | "executeOrderBookTrade"
      | "invalidateOrderNonce"
      | "liquidate"
      | "loadBalanceBySymbol"
      | "loadBalanceInPipsBySymbol"
      | "loadCustodian"
      | "loadFeeWallet"
      | "loadOutstandingWalletFunding"
      | "loadPartiallyFilledOrderQuantityInPips"
      | "loadTotalAccountValue"
      | "loadTotalInitialMarginRequirement"
      | "loadTotalMaintenanceMarginRequirement"
      | "publishFundingMutipliers"
      | "removeAdmin"
      | "removeDispatcher"
      | "setAdmin"
      | "setChainPropagationPeriod"
      | "setCustodian"
      | "setDelegateKeyExpirationPeriod"
      | "setDepositIndex"
      | "setDispatcher"
      | "setFeeWallet"
      | "updateWalletFunding"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "_depositIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_walletExits",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMarket",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeOrderBookTrade",
    values: [
      OrderStruct,
      OrderStruct,
      OrderBookTradeStruct,
      OraclePriceStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "invalidateOrderNonce",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      OraclePriceStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "loadBalanceBySymbol",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "loadBalanceInPipsBySymbol",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "loadCustodian",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "loadFeeWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "loadOutstandingWalletFunding",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "loadPartiallyFilledOrderQuantityInPips",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "loadTotalAccountValue",
    values: [PromiseOrValue<string>, OraclePriceStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "loadTotalInitialMarginRequirement",
    values: [PromiseOrValue<string>, OraclePriceStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "loadTotalMaintenanceMarginRequirement",
    values: [PromiseOrValue<string>, OraclePriceStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "publishFundingMutipliers",
    values: [OraclePriceStruct[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAdmin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeDispatcher",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setChainPropagationPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCustodian",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDelegateKeyExpirationPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDepositIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setDispatcher",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeWallet",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateWalletFunding",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [WithdrawalStruct, OraclePriceStruct[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "_depositIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_walletExits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeOrderBookTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "invalidateOrderNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "loadBalanceBySymbol",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadBalanceInPipsBySymbol",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadCustodian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadFeeWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadOutstandingWalletFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadPartiallyFilledOrderQuantityInPips",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadTotalAccountValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadTotalInitialMarginRequirement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loadTotalMaintenanceMarginRequirement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "publishFundingMutipliers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeDispatcher",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setAdmin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setChainPropagationPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCustodian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDelegateKeyExpirationPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDepositIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDispatcher",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateWalletFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "ChainPropagationPeriodChanged(uint256,uint256)": EventFragment;
    "DelegateKeyExpirationPeriodChanged(uint256,uint256)": EventFragment;
    "Deposited(uint64,address,uint64,int64)": EventFragment;
    "OrderBookTradeExecuted(address,address,string,string,uint64,uint64,uint8)": EventFragment;
    "OrderNonceInvalidated(address,uint128,uint128,uint256)": EventFragment;
    "Withdrawn(address,uint64,int64)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "ChainPropagationPeriodChanged"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "DelegateKeyExpirationPeriodChanged"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderBookTradeExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderNonceInvalidated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export interface ChainPropagationPeriodChangedEventObject {
  previousValue: BigNumber;
  newValue: BigNumber;
}
export type ChainPropagationPeriodChangedEvent = TypedEvent<
  [BigNumber, BigNumber],
  ChainPropagationPeriodChangedEventObject
>;

export type ChainPropagationPeriodChangedEventFilter =
  TypedEventFilter<ChainPropagationPeriodChangedEvent>;

export interface DelegateKeyExpirationPeriodChangedEventObject {
  previousValue: BigNumber;
  newValue: BigNumber;
}
export type DelegateKeyExpirationPeriodChangedEvent = TypedEvent<
  [BigNumber, BigNumber],
  DelegateKeyExpirationPeriodChangedEventObject
>;

export type DelegateKeyExpirationPeriodChangedEventFilter =
  TypedEventFilter<DelegateKeyExpirationPeriodChangedEvent>;

export interface DepositedEventObject {
  index: BigNumber;
  wallet: string;
  quantityInPips: BigNumber;
  newExchangeBalanceInPips: BigNumber;
}
export type DepositedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber],
  DepositedEventObject
>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface OrderBookTradeExecutedEventObject {
  buyWallet: string;
  sellWallet: string;
  baseAssetSymbol: string;
  quoteAssetSymbol: string;
  baseQuantityInPips: BigNumber;
  quoteQuantityInPips: BigNumber;
  takerSide: number;
}
export type OrderBookTradeExecutedEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, number],
  OrderBookTradeExecutedEventObject
>;

export type OrderBookTradeExecutedEventFilter =
  TypedEventFilter<OrderBookTradeExecutedEvent>;

export interface OrderNonceInvalidatedEventObject {
  wallet: string;
  nonce: BigNumber;
  timestampInMs: BigNumber;
  effectiveBlockNumber: BigNumber;
}
export type OrderNonceInvalidatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  OrderNonceInvalidatedEventObject
>;

export type OrderNonceInvalidatedEventFilter =
  TypedEventFilter<OrderNonceInvalidatedEvent>;

export interface WithdrawnEventObject {
  wallet: string;
  quantityInPips: BigNumber;
  newExchangeBalanceInPips: BigNumber;
}
export type WithdrawnEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  WithdrawnEventObject
>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface Exchange_v4 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: Exchange_v4Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _depositIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    _walletExits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & {
        exists: boolean;
        effectiveBlockNumber: BigNumber;
      }
    >;

    addMarket(
      baseAssetSymbol: PromiseOrValue<string>,
      initialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      maintenanceMarginFractionInPips: PromiseOrValue<BigNumberish>,
      incrementalInitialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      baselinePositionSizeInPips: PromiseOrValue<BigNumberish>,
      incrementalPositionSizeInPips: PromiseOrValue<BigNumberish>,
      maximumPositionSizeInPips: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deposit(
      quantityInAssetUnits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeOrderBookTrade(
      buy: OrderStruct,
      sell: OrderStruct,
      orderBookTrade: OrderBookTradeStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    invalidateOrderNonce(
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidate(
      wallet: PromiseOrValue<string>,
      liquidationQuoteQuantitiesInPips: PromiseOrValue<BigNumberish>[],
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    loadBalanceBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BalanceStructOutput]>;

    loadBalanceInPipsBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loadCustodian(overrides?: CallOverrides): Promise<[string]>;

    loadFeeWallet(overrides?: CallOverrides): Promise<[string]>;

    loadOutstandingWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loadPartiallyFilledOrderQuantityInPips(
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loadTotalAccountValue(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loadTotalInitialMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loadTotalMaintenanceMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    publishFundingMutipliers(
      oraclePrices: OraclePriceStruct[],
      fundingRatesInPips: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeAdmin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeDispatcher(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setChainPropagationPeriod(
      newChainPropagationPeriodInBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCustodian(
      newCustodian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDelegateKeyExpirationPeriod(
      newDelegateKeyExpirationPeriodInMs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDepositIndex(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDispatcher(
      newDispatcherWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFeeWallet(
      newFeeWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      withdrawal: WithdrawalStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  _depositIndex(overrides?: CallOverrides): Promise<BigNumber>;

  _walletExits(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber] & { exists: boolean; effectiveBlockNumber: BigNumber }
  >;

  addMarket(
    baseAssetSymbol: PromiseOrValue<string>,
    initialMarginFractionInPips: PromiseOrValue<BigNumberish>,
    maintenanceMarginFractionInPips: PromiseOrValue<BigNumberish>,
    incrementalInitialMarginFractionInPips: PromiseOrValue<BigNumberish>,
    baselinePositionSizeInPips: PromiseOrValue<BigNumberish>,
    incrementalPositionSizeInPips: PromiseOrValue<BigNumberish>,
    maximumPositionSizeInPips: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deposit(
    quantityInAssetUnits: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeOrderBookTrade(
    buy: OrderStruct,
    sell: OrderStruct,
    orderBookTrade: OrderBookTradeStruct,
    oraclePrices: OraclePriceStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  invalidateOrderNonce(
    nonce: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidate(
    wallet: PromiseOrValue<string>,
    liquidationQuoteQuantitiesInPips: PromiseOrValue<BigNumberish>[],
    oraclePrices: OraclePriceStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  loadBalanceBySymbol(
    wallet: PromiseOrValue<string>,
    assetSymbol: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BalanceStructOutput>;

  loadBalanceInPipsBySymbol(
    wallet: PromiseOrValue<string>,
    assetSymbol: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loadCustodian(overrides?: CallOverrides): Promise<string>;

  loadFeeWallet(overrides?: CallOverrides): Promise<string>;

  loadOutstandingWalletFunding(
    wallet: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loadPartiallyFilledOrderQuantityInPips(
    orderHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loadTotalAccountValue(
    wallet: PromiseOrValue<string>,
    oraclePrices: OraclePriceStruct[],
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loadTotalInitialMarginRequirement(
    wallet: PromiseOrValue<string>,
    oraclePrices: OraclePriceStruct[],
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loadTotalMaintenanceMarginRequirement(
    wallet: PromiseOrValue<string>,
    oraclePrices: OraclePriceStruct[],
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  publishFundingMutipliers(
    oraclePrices: OraclePriceStruct[],
    fundingRatesInPips: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeAdmin(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeDispatcher(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAdmin(
    newAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setChainPropagationPeriod(
    newChainPropagationPeriodInBlocks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCustodian(
    newCustodian: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDelegateKeyExpirationPeriod(
    newDelegateKeyExpirationPeriodInMs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDepositIndex(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDispatcher(
    newDispatcherWallet: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFeeWallet(
    newFeeWallet: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateWalletFunding(
    wallet: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    withdrawal: WithdrawalStruct,
    oraclePrices: OraclePriceStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    _depositIndex(overrides?: CallOverrides): Promise<BigNumber>;

    _walletExits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber] & {
        exists: boolean;
        effectiveBlockNumber: BigNumber;
      }
    >;

    addMarket(
      baseAssetSymbol: PromiseOrValue<string>,
      initialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      maintenanceMarginFractionInPips: PromiseOrValue<BigNumberish>,
      incrementalInitialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      baselinePositionSizeInPips: PromiseOrValue<BigNumberish>,
      incrementalPositionSizeInPips: PromiseOrValue<BigNumberish>,
      maximumPositionSizeInPips: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      quantityInAssetUnits: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeOrderBookTrade(
      buy: OrderStruct,
      sell: OrderStruct,
      orderBookTrade: OrderBookTradeStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    invalidateOrderNonce(
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidate(
      wallet: PromiseOrValue<string>,
      liquidationQuoteQuantitiesInPips: PromiseOrValue<BigNumberish>[],
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    loadBalanceBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BalanceStructOutput>;

    loadBalanceInPipsBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadCustodian(overrides?: CallOverrides): Promise<string>;

    loadFeeWallet(overrides?: CallOverrides): Promise<string>;

    loadOutstandingWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadPartiallyFilledOrderQuantityInPips(
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalAccountValue(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalInitialMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalMaintenanceMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    publishFundingMutipliers(
      oraclePrices: OraclePriceStruct[],
      fundingRatesInPips: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    removeAdmin(overrides?: CallOverrides): Promise<void>;

    removeDispatcher(overrides?: CallOverrides): Promise<void>;

    setAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setChainPropagationPeriod(
      newChainPropagationPeriodInBlocks: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCustodian(
      newCustodian: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDelegateKeyExpirationPeriod(
      newDelegateKeyExpirationPeriodInMs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDepositIndex(overrides?: CallOverrides): Promise<void>;

    setDispatcher(
      newDispatcherWallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeWallet(
      newFeeWallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      withdrawal: WithdrawalStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ChainPropagationPeriodChanged(uint256,uint256)"(
      previousValue?: null,
      newValue?: null
    ): ChainPropagationPeriodChangedEventFilter;
    ChainPropagationPeriodChanged(
      previousValue?: null,
      newValue?: null
    ): ChainPropagationPeriodChangedEventFilter;

    "DelegateKeyExpirationPeriodChanged(uint256,uint256)"(
      previousValue?: null,
      newValue?: null
    ): DelegateKeyExpirationPeriodChangedEventFilter;
    DelegateKeyExpirationPeriodChanged(
      previousValue?: null,
      newValue?: null
    ): DelegateKeyExpirationPeriodChangedEventFilter;

    "Deposited(uint64,address,uint64,int64)"(
      index?: null,
      wallet?: null,
      quantityInPips?: null,
      newExchangeBalanceInPips?: null
    ): DepositedEventFilter;
    Deposited(
      index?: null,
      wallet?: null,
      quantityInPips?: null,
      newExchangeBalanceInPips?: null
    ): DepositedEventFilter;

    "OrderBookTradeExecuted(address,address,string,string,uint64,uint64,uint8)"(
      buyWallet?: null,
      sellWallet?: null,
      baseAssetSymbol?: null,
      quoteAssetSymbol?: null,
      baseQuantityInPips?: null,
      quoteQuantityInPips?: null,
      takerSide?: null
    ): OrderBookTradeExecutedEventFilter;
    OrderBookTradeExecuted(
      buyWallet?: null,
      sellWallet?: null,
      baseAssetSymbol?: null,
      quoteAssetSymbol?: null,
      baseQuantityInPips?: null,
      quoteQuantityInPips?: null,
      takerSide?: null
    ): OrderBookTradeExecutedEventFilter;

    "OrderNonceInvalidated(address,uint128,uint128,uint256)"(
      wallet?: null,
      nonce?: null,
      timestampInMs?: null,
      effectiveBlockNumber?: null
    ): OrderNonceInvalidatedEventFilter;
    OrderNonceInvalidated(
      wallet?: null,
      nonce?: null,
      timestampInMs?: null,
      effectiveBlockNumber?: null
    ): OrderNonceInvalidatedEventFilter;

    "Withdrawn(address,uint64,int64)"(
      wallet?: null,
      quantityInPips?: null,
      newExchangeBalanceInPips?: null
    ): WithdrawnEventFilter;
    Withdrawn(
      wallet?: null,
      quantityInPips?: null,
      newExchangeBalanceInPips?: null
    ): WithdrawnEventFilter;
  };

  estimateGas: {
    _depositIndex(overrides?: CallOverrides): Promise<BigNumber>;

    _walletExits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addMarket(
      baseAssetSymbol: PromiseOrValue<string>,
      initialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      maintenanceMarginFractionInPips: PromiseOrValue<BigNumberish>,
      incrementalInitialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      baselinePositionSizeInPips: PromiseOrValue<BigNumberish>,
      incrementalPositionSizeInPips: PromiseOrValue<BigNumberish>,
      maximumPositionSizeInPips: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deposit(
      quantityInAssetUnits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeOrderBookTrade(
      buy: OrderStruct,
      sell: OrderStruct,
      orderBookTrade: OrderBookTradeStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    invalidateOrderNonce(
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidate(
      wallet: PromiseOrValue<string>,
      liquidationQuoteQuantitiesInPips: PromiseOrValue<BigNumberish>[],
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    loadBalanceBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadBalanceInPipsBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadCustodian(overrides?: CallOverrides): Promise<BigNumber>;

    loadFeeWallet(overrides?: CallOverrides): Promise<BigNumber>;

    loadOutstandingWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadPartiallyFilledOrderQuantityInPips(
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalAccountValue(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalInitialMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loadTotalMaintenanceMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    publishFundingMutipliers(
      oraclePrices: OraclePriceStruct[],
      fundingRatesInPips: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeAdmin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeDispatcher(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setChainPropagationPeriod(
      newChainPropagationPeriodInBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCustodian(
      newCustodian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDelegateKeyExpirationPeriod(
      newDelegateKeyExpirationPeriodInMs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDepositIndex(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDispatcher(
      newDispatcherWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFeeWallet(
      newFeeWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      withdrawal: WithdrawalStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _depositIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _walletExits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addMarket(
      baseAssetSymbol: PromiseOrValue<string>,
      initialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      maintenanceMarginFractionInPips: PromiseOrValue<BigNumberish>,
      incrementalInitialMarginFractionInPips: PromiseOrValue<BigNumberish>,
      baselinePositionSizeInPips: PromiseOrValue<BigNumberish>,
      incrementalPositionSizeInPips: PromiseOrValue<BigNumberish>,
      maximumPositionSizeInPips: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      quantityInAssetUnits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeOrderBookTrade(
      buy: OrderStruct,
      sell: OrderStruct,
      orderBookTrade: OrderBookTradeStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    invalidateOrderNonce(
      nonce: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidate(
      wallet: PromiseOrValue<string>,
      liquidationQuoteQuantitiesInPips: PromiseOrValue<BigNumberish>[],
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    loadBalanceBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadBalanceInPipsBySymbol(
      wallet: PromiseOrValue<string>,
      assetSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadCustodian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    loadFeeWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    loadOutstandingWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadPartiallyFilledOrderQuantityInPips(
      orderHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadTotalAccountValue(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadTotalInitialMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loadTotalMaintenanceMarginRequirement(
      wallet: PromiseOrValue<string>,
      oraclePrices: OraclePriceStruct[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    publishFundingMutipliers(
      oraclePrices: OraclePriceStruct[],
      fundingRatesInPips: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeAdmin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeDispatcher(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setChainPropagationPeriod(
      newChainPropagationPeriodInBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCustodian(
      newCustodian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDelegateKeyExpirationPeriod(
      newDelegateKeyExpirationPeriodInMs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDepositIndex(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDispatcher(
      newDispatcherWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFeeWallet(
      newFeeWallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateWalletFunding(
      wallet: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      withdrawal: WithdrawalStruct,
      oraclePrices: OraclePriceStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
